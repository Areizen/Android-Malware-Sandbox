import glob
import importlib
from pathlib import Path

from datetime import datetime

from lib.adb import Device
from lib.model import Application, Url, Rendering
from lib.model.Analysis import Analysis
from lib.model.database.Database import Database
from lib.receiver.Frida import Frida
from lib.receiver.Proxy import Proxy

import logging
import time
import uuid

from lib.report.ReportGenerator import ReportGenerator

import os.path
import os

dirname = os.path.realpath(os.path.dirname(os.path.realpath(__file__))+'/../../')


class Core:

    def __init__(self, configuration, device: Device, module, path: str):
        self.configuration = configuration
        self.device = device
        self.path = path
        self.module = module
        self.session = None
        self.timeout = int(configuration['ANALYSIS'].get('analysis_timeout'))
        self.plugins = self.load_plugins()
        self.renderPlugins = {}

        # Object used by the core
        self.current_application = None
        self.receivers = []

        # Database initialisation
        session = Database.get_session()
        self.analysis = Analysis(uuid=str(uuid.uuid4()), date=datetime.now())
        session.add(self.analysis)
        session.commit()

        self.report_path = f"{dirname}/reports/{self.analysis.date}_{self.analysis.id}/"

    def select_applications(self):
        '''
        Return the applications that will be analyzed
        :return:
        '''
        logging.debug("Core:select_applications()")
        return self.module.select(self.path, )


    def get_result_plugins(self):
        # Get result of plugins i.e. Frida Hooks
        session = Database.get_session()
        counter = 0
        for i in range(len(self.plugins)):
            # Name of plugin
            clazzName = list(self.plugins[i].__dict__.keys())[11]
            # Get plugin's class
            clazz = self.plugins[i].__getattribute__(clazzName)
            query = session.query(clazz).filter(clazz.application_id==self.current_application.id)
            resultQuery = query.all()
            
            clazzDict = clazz.__dict__
            keys = list(clazzDict.keys())

            pluginList = []
            for plugin in query:
                attributesDict = {}
                for key in keys:
                    if not key.startswith('_'):
                        attributesDict[key] = plugin.__getattribute__(key)
                if len(attributesDict) != 0:
                    pluginList.append(attributesDict)

            if len(pluginList) != 0:
                self.renderPlugins[clazzName] = pluginList

        # for pluginName, listPluginInstance in self.renderPlugins.items():
        #     print(listPluginInstance)
        #     for pluginInstance in listPluginInstance:
        #         for key, value in pluginInstance.items():
        #             print(key)
        #             print(value)


    def start_analysis(self):
        '''
        Launch the analysis process and loop trough all apk
        then generate the according report
        :return:
        '''
        logging.debug("Core:start_analysis()")

        apk_paths = self.select_applications()

        if self.configuration['ANALYSIS'].getboolean('use_proxy'):
            certificate = self.configuration['PROXY'].get('proxy_certificate')
            if os.path.isfile(certificate) != 0:
                self.device.install_certificate(certificate)

        if self.configuration['ANALYSIS'].getboolean('use_frida'):
            plugin_code = map(lambda x:x.get_frida_script(),self.plugins)
            Frida.compile(configuration=self.configuration,plugin_code=plugin_code)
            self.device.install_frida()
        
        # creating the report output folder
        os.mkdir(self.report_path)

        for apk in apk_paths:
            try:
                self.analyse_sample(Path(apk).absolute())
            except Exception as e:
                logging.error(e)
                pass

        self.get_result_plugins()

        # Rapport generating
        generator = ReportGenerator()
        rendering = Rendering.Rendering(self.analysis, self.renderPlugins)
        report_path = generator.generate(self.report_path, rendering)
        path = str(Path(report_path).absolute())
        logging.info(f"Report generated to {path}")


    def check_apk_is_valid(self):
        files = self.current_application.get_files()
        arch = self.device.get_device_arch()
        is_apk_valid = False
        found = False
        for i in files:
            if ("lib/" in i):
                logging.info(f"Library : {i}")
                found = True
                if (arch in i):
                    is_apk_valid = True
        if (found == False):
            is_apk_valid = True

        return is_apk_valid

    def analyse_sample(self, apk_path):
        '''
        Analyze the given apk
        :param apk_path:
        :return:
        '''
        logging.debug("Core:analyse_sample()")
        self.current_application = Application.Application(apk_path)

        if not self.check_apk_is_valid():
            logging.error(f"The apk architecture and the device architecture ({self.device.get_device_arch()})  doesn't match for application : {self.current_application.filename}")
            return

        # Database storing
        session = Database.get_session()
        self.analysis.application.append(self.current_application)
        session.add(self.current_application)
        session.commit()
    
        logging.info(f"Package name: {self.current_application.package}")
        logging.info(f"Main activity: {self.current_application.get_main_activity()}")
        logging.info(f"Path : {self.current_application.path}")
        logging.info(f"SHA256 : {self.current_application.get_sha256_hash()}")
        logging.info(f"Accessibility services : {self.current_application.get_accessibility_services()}")
        logging.info(f"Administrator receivers : {self.current_application.get_administrator_receivers()}")


        time_init = time.time()
        module = self.module(self.device, self.current_application,self.plugins)
        try:
            if(self.device.type=="Physical" and self.current_application.package in self.device.list_third_party()):
                self.device.uninstall_application(self.current_application.package)
            
            self.device.install_application(self.current_application.path, self.configuration['ANALYSIS'].getboolean('auto_grant_permissions'))
            self.start_receivers(module)

            # Automatically enable accessibility services of an application
            self.device.enable_accessibility_services(self.current_application)

            current_time = 0
            while current_time < self.timeout or self.module.stop == False or ( self.timeout == -1 and self.device.check_is_up() ) :
                current_time = time.time() - time_init
                logging.debug(f"{int(current_time)}/{self.timeout} seconds")
                time.sleep(1)
        
           
            self.stop_receivers()

            # pulling the internal files if the options is choosed
            if(self.configuration['ANALYSIS'].getboolean("pull_files")):
                self.device.pull_application_internal_files(self.current_application.package, f"{self.report_path}/{self.current_application.package}_{self.current_application.get_sha256_hash()}")

            if(self.timeout!= -1):
                self.device.uninstall_application(self.current_application.package)
        
        except Exception as e:
            logging.error(e)
            self.device.uninstall_application(self.current_application.package)
            self.stop_receivers()
            print(e)



    def start_receivers(self, module):
        '''
        Start handler that handles the devices interactions
        :param module:
        :return:
        '''
        logging.debug("Core:start_receivers()")

        use_frida = self.configuration['ANALYSIS'].getboolean('use_frida')
        use_proxy = self.configuration['ANALYSIS'].getboolean('use_proxy')

        if use_proxy:
            proxy = Proxy(self.configuration['PROXY'], module)
            proxy.start()
            self.receivers.append(proxy)

        if use_frida:
            frida = Frida(self.configuration['FRIDA'], module, self.device)
            frida.start()
            self.receivers.append(frida)
        else:
            self.device.launch_application(self.current_application.package)

        logging.debug("Core:start_receivers() -> Started")




    def stop_receivers(self):
        '''
        Stop all current handlers
        :return:
        '''
        logging.debug("Core:stop_receivers()")

        for i in range(len(self.receivers)):
            self.receivers[i].stop()

        self.receivers = []



    def load_plugins(self):
        """
        Import all plugins in plugins folder
        :return:
        """
        plugins = glob.glob("plugins/**/plugin.py", recursive=True)

        normalize = lambda x: x.replace('/', '.')[:-3]
        plugins = map(normalize, plugins)
        selected_plugins = []
        _plugins = []
        use_plugins = self.configuration['PLUGINS'].items()
        for item_name, selected in use_plugins:
            if selected == 'yes':
                logging.info(f"Plugin: {item_name}")
                selected_plugins.append(item_name)
        for plugin in plugins:
            pluginName = plugin.split(".")[1]
            if (not plugin.startswith('__')) and (pluginName in selected_plugins):
                module = importlib.import_module(plugin)
                module.onload()
                _plugins.append(module)
        return _plugins